{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Micron.js\n\n\nALPHA\n\n\n\n\n\n\nMicron is a minimalistic (around 2k lines of code) 2d js game/app/experiments framework creation. \nIt uses heavily \nbasejs\n, and it is inspired by a shitload of other frameworks and tools.\n\n\nHave Fun!\n\n\nFork", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-micronjs", 
            "text": "ALPHA    Micron is a minimalistic (around 2k lines of code) 2d js game/app/experiments framework creation. \nIt uses heavily  basejs , and it is inspired by a shitload of other frameworks and tools.  Have Fun!  Fork", 
            "title": "Welcome to Micron.js"
        }, 
        {
            "location": "/reference/core/core/", 
            "text": "Core\n\n\nSingleton\n \n\n\nThe Core is the... core of the framework: it links all the submodules together. \nThis is the one that controls the actual game and the state machine.\nYou won't likely have to modify this class.\n\n\nMembers\n\n\n\n\ncurrentState\n\n\ncurrentState : State\n\n\n\nThe current \nState\n in execution.\n\n\n\n\nwidth\n\n\nwidth : Number\n\n\n\nread-only\n \n\n\n\n\nheight\n\n\nheight : Number\n\n\n\nread-only\n\n\n\n\nisStorageAvailable\n\n\nisStorageAvailable : Boolean\n\n\n\nread-only\n If localStorage is available, this flag is true.\n\n\n\n\nfps\n\n\nfps : Number\n\n\n\nread-only\n Mean of frames per second in the last second.\n\n\n\n\ntotalTime\n\n\ntotalTime : Number\n\n\n\nTotal time elapsed since the game started. Only counts when the game is not paused.\n\n\n\n\ndelta\n\n\ndelta : Number\n\n\n\nread-only\n The delta time between this frame and the previous one.\n\n\n\n\ntimeScale\n\n\ntimeScale : Number\n\n\n\nThis value controls how fast or slow things are updated. 1.0 is the default value.\n\n\nNOTE\n: Bigger values will make things move faster, smaller values will make it move slower. 0 is totally paused.\n\n\n\n\nisPaused\n\n\nisPaused : Boolean\n\n\n\nWhen this is \ntrue\n, the game is paused. False otherwise. Do not attempt to set this manually to pause the game, \nyou must use \nCore.pause\n instead.\n\n\n\n\nassets\n\n\nassets : Object\n\n\n\nAll the assets loaded. Kept in case someone wants just to iterate through assets quickly. \nThere is a map version available, smartly named assetsMap.\n\n\n\n\nassetsLoaded\n\n\nassetsLoaded : Number\n\n\n\nThe amount of assets loaded at any given time. When core executes init in your gamestate, this should be \n= assets.length.\n\n\n\n\nMethods\n\n\n\n\ninit\n\n\ninit (width, height)\n\n\n\nPass the size the game should have on the screen. It will be rescaled and recentered automatically.\n\n\n\n\nupdate\n\n\nupdate (delta)\n\n\n\nEverything is updated from here: the gamestate, the fps counter, the tweens, etc. This is the source of them all.\n\n\n\n\ndraw\n\n\ndraw ()\n\n\n\nLike update, draw is the source method for all draw calls to happen in micron. \nIf you need to do weird interstate drawing, pause or similar, this is your place.\n\n\n\n\nrun\n\n\nrun ()\n\n\n\nAn internal function, this is called by requestAnimFrame to update and draw everything. This is the heart of the loop.\n\n\n\n\npause\n\n\npause (flag : Boolean)\n\n\n\nA handy method for pausing the game from code.    \n\n\n\n\nsetState\n\n\nsetState (state)\n\n\n\nSwitch the current state. It will delete the previous one, but not the underlaying assets in Core - you have to wipe them manually.\n\n\n\n\ngetFPS\n\n\ngetFPS ()\n\n\n\nReturn the current internal fps amount. Note that this is a bit innacurate. \n\n\n\n\naddAsset\n\n\naddAsset (pathOrArray)\n\n\n\nExample: \nCore.addAsset([ \"empty\", \"gfx/empty.jpg\" ]);\n The first parameter is the \nkey\n, the second, the path.\n\n\n\n\nloadAndRun\n\n\nloadAndRun ()\n\n\n\nCall after adding all your assets to start executing the current state.\nYou can also call this without loading any asset - it will just start running your app/game/thing.\n\n\n\n\nhasStorageSupport\n\n\nhasStorageSupport ()\n\n\n\nReturns \ntrue\n if your browser supports local storage.\n\n\n\n\nsaveToStorage\n\n\nsaveToStorage (name, value)\n\n\n\nA simple way to save things to local storage. Example: \nCore.saveToStorage( \"MyPlayer\", { x: 10, y: 20, name: \"Hodor\" } ]);\n    \n\n\n\n\nreadFromStorage\n\n\nreadFromStorage (name)\n\n\n\nReturns the object/value by that name. If nothing is found by that name key, it returns \nnull\n.", 
            "title": "Core"
        }, 
        {
            "location": "/reference/core/core/#core", 
            "text": "Singleton    The Core is the... core of the framework: it links all the submodules together. \nThis is the one that controls the actual game and the state machine.\nYou won't likely have to modify this class.", 
            "title": " Core"
        }, 
        {
            "location": "/reference/core/core/#members", 
            "text": "currentState  currentState : State  The current  State  in execution.   width  width : Number  read-only     height  height : Number  read-only   isStorageAvailable  isStorageAvailable : Boolean  read-only  If localStorage is available, this flag is true.   fps  fps : Number  read-only  Mean of frames per second in the last second.   totalTime  totalTime : Number  Total time elapsed since the game started. Only counts when the game is not paused.   delta  delta : Number  read-only  The delta time between this frame and the previous one.   timeScale  timeScale : Number  This value controls how fast or slow things are updated. 1.0 is the default value.  NOTE : Bigger values will make things move faster, smaller values will make it move slower. 0 is totally paused.   isPaused  isPaused : Boolean  When this is  true , the game is paused. False otherwise. Do not attempt to set this manually to pause the game, \nyou must use  Core.pause  instead.   assets  assets : Object  All the assets loaded. Kept in case someone wants just to iterate through assets quickly. \nThere is a map version available, smartly named assetsMap.   assetsLoaded  assetsLoaded : Number  The amount of assets loaded at any given time. When core executes init in your gamestate, this should be  = assets.length.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/core/core/#methods", 
            "text": "init  init (width, height)  Pass the size the game should have on the screen. It will be rescaled and recentered automatically.   update  update (delta)  Everything is updated from here: the gamestate, the fps counter, the tweens, etc. This is the source of them all.   draw  draw ()  Like update, draw is the source method for all draw calls to happen in micron. \nIf you need to do weird interstate drawing, pause or similar, this is your place.   run  run ()  An internal function, this is called by requestAnimFrame to update and draw everything. This is the heart of the loop.   pause  pause (flag : Boolean)  A handy method for pausing the game from code.       setState  setState (state)  Switch the current state. It will delete the previous one, but not the underlaying assets in Core - you have to wipe them manually.   getFPS  getFPS ()  Return the current internal fps amount. Note that this is a bit innacurate.    addAsset  addAsset (pathOrArray)  Example:  Core.addAsset([ \"empty\", \"gfx/empty.jpg\" ]);  The first parameter is the  key , the second, the path.   loadAndRun  loadAndRun ()  Call after adding all your assets to start executing the current state.\nYou can also call this without loading any asset - it will just start running your app/game/thing.   hasStorageSupport  hasStorageSupport ()  Returns  true  if your browser supports local storage.   saveToStorage  saveToStorage (name, value)  A simple way to save things to local storage. Example:  Core.saveToStorage( \"MyPlayer\", { x: 10, y: 20, name: \"Hodor\" } ]);        readFromStorage  readFromStorage (name)  Returns the object/value by that name. If nothing is found by that name key, it returns  null .", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/core/state/", 
            "text": "State : Entity\n\n\nClass\n\n\nState is an encapsulation of a \"game\" state: for example,\nthe screens on a game. They should hold the logic for each screen and manipulate high level entities.\n\n\nIMPORTANT\n: you must create your objects that depend on resources in your \ninit\n method,\nsince this is the one called when all resources are ready.\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor ()\n\n\n\n\n\n### init\n\n\ninit ()\n\n\n\nOverride to create here the objects that require fully loaded resources.\nEverything else can go to the constructor.\n\n\n\n\nonPause\n\n\nonPause (flag)\n\n\n\nOverride this method to control what happens when the application is paused or not\n(that's what the flag is for: it receives true when paused).", 
            "title": "State"
        }, 
        {
            "location": "/reference/core/state/#state-entity", 
            "text": "Class  State is an encapsulation of a \"game\" state: for example,\nthe screens on a game. They should hold the logic for each screen and manipulate high level entities.  IMPORTANT : you must create your objects that depend on resources in your  init  method,\nsince this is the one called when all resources are ready.", 
            "title": " State : Entity"
        }, 
        {
            "location": "/reference/core/state/#methods", 
            "text": "constructor  constructor ()   ### init  init ()  Override to create here the objects that require fully loaded resources.\nEverything else can go to the constructor.   onPause  onPause (flag)  Override this method to control what happens when the application is paused or not\n(that's what the flag is for: it receives true when paused).", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/core/entity/", 
            "text": "Entity\n\n\nClass\n\n\nThe mother of all other things in the engine. GameStates, Sprites, Atlases, Sounds (ok, maybe not sounds) but everything is an entity.\nEntities have the most basic behavior: they are holders of entities. As such, they have \ninit, update\n and \ndraw\n methods.\nEntities also can be \npooled, cloned\n or \ndestroyed\n.\nIf you don't know what kind of class you need but you know you will have to update it or make it a cointainer for other things, this is the class you must extend.\nFor everything else, you should extend from \nBase\n.\n\n\nMembers\n\n\n\n\nname\n\n\nname : String\n\n\n\nAn identifier to easily find your object.\n\n\n\n\nentities\n\n\nentities : Array\n\n\n\nThe array with all your entities added to this entity.    \n\n\n\n\ninUse\n\n\ninUse : true\n\n\n\nThis is true to keep consistency with non-pooled object. And yes, this flag is used when pooling.\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (name)\n\n\n\n\n\nspawn\n\n\nspawn ()\n\n\n\nOverride when pooling.\n\n\n\n\nadd\n\n\nadd (entity)\n\n\n\nAdd another entity inside this one as child. This means that doing callParent in update and draw for this entity,\nwill also call automatically update and draw for the child entities of this one. \nHandy for creating hierarchies of entities quickly and avoid calling manually \nupdate\n and \ndraw\n.\n\n\n\n\nremove\n\n\nremove (entity)\n\n\n\nRemoves the given entity (if exists). This doesn't destroy the removed object, it just removes it from the hierarchy.\n\n\n\n\nremoveAll\n\n\nremoveAll ()\n\n\n\nLike remove, but for all children items.\n\n\n\n\nclone\n\n\nclone ()\n\n\n\nA simple method that returns a new object which has all its attributes with the same value as the one cloned.\nUseful for creating duplicated instances of the same object to modify later.\n\n\n\n\nupdate\n\n\nupdate (delta)\n\n\n\nIf your entity was added to the state or another one added to state, then this will be called automatically once per frame.\nIf not, you must call this manually to \"tick\" your entity.\nRemember to do \nthis.callParent(delta)\n inside your update if you want to tick the \nchildren\n entities of this.\n\n\n\n\ndraw\n\n\ndraw ()\n\n\n\nExactly like the case for update, but for this we control what we draw.    \n\n\n\n\ndestroy\n\n\ndestroy ()\n\n\n\nCalls destroy on all of its children. Useful to release/delete what no longer is needed to destroy your entity (and its children).", 
            "title": "Entity"
        }, 
        {
            "location": "/reference/core/entity/#entity", 
            "text": "Class  The mother of all other things in the engine. GameStates, Sprites, Atlases, Sounds (ok, maybe not sounds) but everything is an entity.\nEntities have the most basic behavior: they are holders of entities. As such, they have  init, update  and  draw  methods.\nEntities also can be  pooled, cloned  or  destroyed .\nIf you don't know what kind of class you need but you know you will have to update it or make it a cointainer for other things, this is the class you must extend.\nFor everything else, you should extend from  Base .", 
            "title": " Entity"
        }, 
        {
            "location": "/reference/core/entity/#members", 
            "text": "name  name : String  An identifier to easily find your object.   entities  entities : Array  The array with all your entities added to this entity.       inUse  inUse : true  This is true to keep consistency with non-pooled object. And yes, this flag is used when pooling.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/core/entity/#methods", 
            "text": "constructor  constructor (name)   spawn  spawn ()  Override when pooling.   add  add (entity)  Add another entity inside this one as child. This means that doing callParent in update and draw for this entity,\nwill also call automatically update and draw for the child entities of this one. \nHandy for creating hierarchies of entities quickly and avoid calling manually  update  and  draw .   remove  remove (entity)  Removes the given entity (if exists). This doesn't destroy the removed object, it just removes it from the hierarchy.   removeAll  removeAll ()  Like remove, but for all children items.   clone  clone ()  A simple method that returns a new object which has all its attributes with the same value as the one cloned.\nUseful for creating duplicated instances of the same object to modify later.   update  update (delta)  If your entity was added to the state or another one added to state, then this will be called automatically once per frame.\nIf not, you must call this manually to \"tick\" your entity.\nRemember to do  this.callParent(delta)  inside your update if you want to tick the  children  entities of this.   draw  draw ()  Exactly like the case for update, but for this we control what we draw.       destroy  destroy ()  Calls destroy on all of its children. Useful to release/delete what no longer is needed to destroy your entity (and its children).", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/core/pool/", 
            "text": "Pool : Entity\n\n\nClass\n\n\nPools are extremely simple... erh... pools of \nEntities\n. When making a pool for your objects, they must have:\n- a flag to determine the state of the object (\ninUse\n).\n- a method to re-spawn the object when it's back to the world (\nspawn\n).\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor ()\n\n\n\n\n\naddToPool\n\n\naddToPool (object, amount)\n\n\n\nBefore pooling objects, you must first add the \"model\" ones.\nJust put any poolable object and how many \"unique\" objects you want.\n\n\n\n\nspawn\n\n\nspawn (amount)\n\n\n\nDetermine how many death objects should be respawned.\nIt will spawn as many as possible. If there won't be enough, it will do nothing.\n\n\n\n\nspawn\n\n\nupdate (delta)\n\n\n\n\n\ndraw\n\n\ndraw ()", 
            "title": "Pool"
        }, 
        {
            "location": "/reference/core/pool/#pool-entity", 
            "text": "Class  Pools are extremely simple... erh... pools of  Entities . When making a pool for your objects, they must have:\n- a flag to determine the state of the object ( inUse ).\n- a method to re-spawn the object when it's back to the world ( spawn ).", 
            "title": " Pool : Entity"
        }, 
        {
            "location": "/reference/core/pool/#methods", 
            "text": "constructor  constructor ()   addToPool  addToPool (object, amount)  Before pooling objects, you must first add the \"model\" ones.\nJust put any poolable object and how many \"unique\" objects you want.   spawn  spawn (amount)  Determine how many death objects should be respawned.\nIt will spawn as many as possible. If there won't be enough, it will do nothing.   spawn  update (delta)   draw  draw ()", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/input/", 
            "text": "Input\n\n\nSingleton\n \n\n\nThe main Input module is reponsible for detecting and processing input events. On mobile devices, clicks are handled as touches (but work exactly the same).\nYou can register objects to the input system to receive \"touch\" events. \n\n\nExample:\n inside a class, do Input.addInputReceiver(this), and then override the method \nonClickInput\n.\n\n\n\n\nMembers\n\n\n\n\nisClick\n\n\nisClick : Boolean\n\n\n\nread-only\n\n\n\n\nclickPosition\n\n\nclickPosition : object{ x, y }\n\n\n\nread-only\n\n\n\n\nmousePosition\n\n\nmousePosition : { x, y }\n\n\n\nread-only\n\n\n\n\ninputObjectsRegistered\n\n\ninputObjectsRegistered : Array\n\n\n\nread-only\n\n\n\n\nsupportsMultitouch\n\n\nsupportsMultitouch : false\n\n\n\nread-only\n\n\n\n\nExample:\n \nInput.isKeyPressed( Input.KEY_ESC );\n\n\nKEY_BACK KEY_TAB KEY_ENTER KEY_SHIFT KEY_CTRL  KEY_ALT  KEY_PAUSE  KEY_CLOCK  KEY_ESC  KEY_SPACE KEY_PGUP KEY_PGDOWN KEY_END KEY_HOME\nKEY_LEFT KEY_UP KEY_RIGHT KEY_DOWN KEY_INSERT KEY_DEL KEY_0 KEY_1 KEY_2 KEY_3 KEY_4 KEY_5 KEY_6 KEY_7 KEY_8 KEY_9 KEY_A KEY_B KEY_C \nKEY_D KEY_E KEY_F KEY_G KEY_H KEY_I KEY_J KEY_K KEY_L KEY_M KEY_N KEY_O KEY_P KEY_Q KEY_R KEY_S KEY_T KEY_U KEY_V KEY_W KEY_X KEY_Y   \n\nKEY_Z KEY_NUM0 KEY_NUM1 KEY_NUM2 KEY_NUM3 KEY_NUM4 KEY_NUM5 KEY_NUM6 KEY_NUM7 KEY_NUM8 KEY_NUM9 KEY_MUL KEY_ADD KEY_SUB KEY_POINT KEY_DIV \n\n\nread-only\n\n\n\n\nMethods\n\n\n\n\ncheckMulitouchSupport\n\n\ncheckMulitouchSupport () : Boolean\n\n\n\n\n\naddInputReceiver\n\n\naddInputReceiver (object)\n\n\n\nWhen registering your object to receive touch/click input, don't forget to override in your object the method \nonClickInput(x, y)\n\n\nExample\n: \n\n\nonClickInput : function(x, y){ \n    if(this.isPointInRect(...){ \n        console.log(\nclick!\n); \n    }\n};\n\n\n\n\n\n\nisKeyPressed\n\n\nisKeyPressed (key) : bool\n\n\n\n\n\nisMousePressed\n\n\nisMousePressed () : bool\n\n\n\n\n\nisMouseReleased\n\n\nisMouseReleased () : bool\n\n\n\n\n\ngenerateClick\n\n\ngenerateClick (xpos, ypos)\n\n\n\n\n\nreleaseClick\n\n\nreleaseClick ()\n\n\n\n\n\nmouseMoved\n\n\nmouseMoved (x, y)\n\n\n\n\n\ngetMousePosition\n\n\ngetMousePosition () : object{x, y}\n\n\n\n\n\ngetMousePositionInWorld\n\n\ngetMousePositionInWorld () : object{x, y}", 
            "title": "Input"
        }, 
        {
            "location": "/reference/input/#input", 
            "text": "Singleton    The main Input module is reponsible for detecting and processing input events. On mobile devices, clicks are handled as touches (but work exactly the same).\nYou can register objects to the input system to receive \"touch\" events.   Example:  inside a class, do Input.addInputReceiver(this), and then override the method  onClickInput .", 
            "title": " Input"
        }, 
        {
            "location": "/reference/input/#members", 
            "text": "isClick  isClick : Boolean  read-only   clickPosition  clickPosition : object{ x, y }  read-only   mousePosition  mousePosition : { x, y }  read-only   inputObjectsRegistered  inputObjectsRegistered : Array  read-only   supportsMultitouch  supportsMultitouch : false  read-only   Example:   Input.isKeyPressed( Input.KEY_ESC );  KEY_BACK KEY_TAB KEY_ENTER KEY_SHIFT KEY_CTRL  KEY_ALT  KEY_PAUSE  KEY_CLOCK  KEY_ESC  KEY_SPACE KEY_PGUP KEY_PGDOWN KEY_END KEY_HOME\nKEY_LEFT KEY_UP KEY_RIGHT KEY_DOWN KEY_INSERT KEY_DEL KEY_0 KEY_1 KEY_2 KEY_3 KEY_4 KEY_5 KEY_6 KEY_7 KEY_8 KEY_9 KEY_A KEY_B KEY_C \nKEY_D KEY_E KEY_F KEY_G KEY_H KEY_I KEY_J KEY_K KEY_L KEY_M KEY_N KEY_O KEY_P KEY_Q KEY_R KEY_S KEY_T KEY_U KEY_V KEY_W KEY_X KEY_Y    \nKEY_Z KEY_NUM0 KEY_NUM1 KEY_NUM2 KEY_NUM3 KEY_NUM4 KEY_NUM5 KEY_NUM6 KEY_NUM7 KEY_NUM8 KEY_NUM9 KEY_MUL KEY_ADD KEY_SUB KEY_POINT KEY_DIV   read-only", 
            "title": "Members"
        }, 
        {
            "location": "/reference/input/#methods", 
            "text": "checkMulitouchSupport  checkMulitouchSupport () : Boolean   addInputReceiver  addInputReceiver (object)  When registering your object to receive touch/click input, don't forget to override in your object the method  onClickInput(x, y)  Example :   onClickInput : function(x, y){ \n    if(this.isPointInRect(...){ \n        console.log( click! ); \n    }\n};   isKeyPressed  isKeyPressed (key) : bool   isMousePressed  isMousePressed () : bool   isMouseReleased  isMouseReleased () : bool   generateClick  generateClick (xpos, ypos)   releaseClick  releaseClick ()   mouseMoved  mouseMoved (x, y)   getMousePosition  getMousePosition () : object{x, y}   getMousePositionInWorld  getMousePositionInWorld () : object{x, y}", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/graphics/graphics/", 
            "text": "Graphics\n\n\nSingleton\n\n\nThe heavy rendering part of Micron. \nGraphics\n groups all the drawXXX methods, as well as image loading and manipulation.\n\n\nIMPORTANT\n: there are several considerations you should know:\n\n\n\n\nColor (\nr, g, b, a\n components for \nRed\n, \nGreen\n, \nBlue\n and \nAlpha\n) are always normalized values between 0..1.\n\n\nPosition: all the values you pass as position coordinates (\nx, y\n) are from the \nupper left corner\n of the image or primitive.\n\n\nRotation and scale: the values passed for rotation and scaling are considered from the \ncenter\n of the image or primitive.\n\n\n\n\n\n\nMembers\n\n\n\n\ncanvas\n\n\ncanvas : object{Canvas}\n\n\n\nThe basic \ncanvas\n object. Feel free to manipulate it directly to suit your needs.\n\n\n\n\ncontext\n\n\ncontext : object{Canvas2DContext}\n\n\n\nread-only\n\n\n\n\nimages\n\n\nimages : Array\n\n\n\nThe list of all the images loaded by Graphics. Useful to have access to the raw ImageElement data.\n\n\n\n\nimagesMap\n\n\nimagesMap : {}\n\n\n\nSame as above, but in form of map.\n\n\n\n\nautoClearScreen\n\n\nautoClearScreen : Boolean\n\n\n\nFlag. When true (which it is, by default), it will clear the screen automatically before drawing. If false, the user will have to do it manually.\nThis is very useful to create several FX as blur (combined with drawing in full screen with low alpha values).\n\n\n\n\nMethods\n\n\n\n\ninit\n\n\ninit (width, height)\n\n\n\nCalled automatically by Core. No matter how big or small is your game window, you will always have \nwidth,height\n pixels in your app.\n\n\n\n\npixelify\n\n\npixelify (flag)\n\n\n\nIf flag is \ntrue\n, all the textures will be displayed using nearest filtering. Useful for 8bit/pixelart games.\n\n\n\n\ngetWidth\n\n\ngetWidth ()\n\n\n\nReturn the width of your virtual window (the same value you provided in init). The same as Core.width.\n\n\n\n\ngetHeight\n\n\ngetHeight ()\n\n\n\nSee above and change width by height.\n\n\n\n\nloadImage\n\n\nloadImage (alias, path)\n\n\n\nAll images loaded have an alias. The path can be any local image or link.\n\n\n\n\ngetImage\n\n\ngetImage (pathOrAlias)\n\n\n\nGet an [Image] object previously loaded, using it's path or alias. Better use the alias (it's simpler).\n\n\n\n\npreDraw\n\n\npreDraw ()\n\n\n\nYou shouldn't have to touch these two, but in case you need to alter the default drawing of the entire engine: here's the place to do so.\n\n\n\n\npostDraw\n\n\npostDraw ()\n\n\n\n\n\nenableBlur\n\n\nenableBlur (size, r, g, b, a)\n\n\n\nStart drawing \"blur\". It will create a blurry halo around everything you draw. It can kill performance.\n\n\n\n\ndisableBlur\n\n\ndisableBlur()\n\n\n\nStop using blur.\n\n\n\n\ndrawText\n\n\ndrawText (text, x, y, r, g, b, a, size : number, [font=defaultFont] : string)\n\n\n\nExample:\n \nGraphics.drawText(\"Hello world!\", 0, 0, 1, 1, 1, 1, 32, \"Arial\");\n\n\n\n\ndrawRect\n\n\ndrawRect (x, y, width, height, r, g, b, a, [mode=\"fill\"])\n\n\n\nFor all the methods that have a \"mode\" parameter, it can always be either \n\"fill\"\n or \n\"stroke\"\n.\n\n\n\n\ndrawFullScreenRect\n\n\ndrawFullScreenRect (r,g,b,a)\n\n\n\nDraws a rectangle in fullscreen, no matter where the Camera is.\n\n\n\n\ndrawLine\n\n\ndrawLine (x1, y1, x2, y2, r, g, b, a, lineWidth, [round])\n\n\n\nIf round is not empty, it will be used to define lineCap.\n\n\n\n\ndrawArc\n\n\ndrawArc (x, y, radius, startAngle, endAngle, r, g, b, a, lineWidth, [mode=\"fill\"])\n\n\n\nDraw an arc. Can be used to draw circles as well, but it is better to use drawCircle instead.\n\n\n\n\ndrawCircle\n\n\ndrawCircle (x, y, radius, r, g, b, a, [mode=\"fill\"])\n\n\n\n\n\ndrawSprite\n\n\ndrawSprite (path, x, y, width, height, angle, scaleX, scaleY, alpha)\n\n\n\nPath can be the full path to the image or the key used when the asset is loaded.\n\n\n\n\ndrawSpriteCropped\n\n\ndrawSpriteCropped (img:[Image], x, y, width, height, angle, scaleX, scaleY, alpha, uvX, uvY, uvW, uvH)\n\n\n\nA \ncropped\n sprite displays a part of the texture defined by its uv in pixels.\n\n\n\n\ndrawPolygon\n\n\ndrawPolygon (points : array, x, y, r, g, b, a, [mode=\"fill\"])\n\n\n\nThe \npoints\n array must have a pair number of elements. Each succesive value is a pair (x,y).\n\n\n\n\ndrawRegularPolygon\n\n\ndrawRegularPolygon (x, y, numberOfSides, size, r, g, b, a, [mode=\"fill\"])\n\n\n\nA regular polygon is the one which has all sides equally long. From 3 up to infinite.", 
            "title": "Graphics"
        }, 
        {
            "location": "/reference/graphics/graphics/#graphics", 
            "text": "Singleton  The heavy rendering part of Micron.  Graphics  groups all the drawXXX methods, as well as image loading and manipulation.  IMPORTANT : there are several considerations you should know:   Color ( r, g, b, a  components for  Red ,  Green ,  Blue  and  Alpha ) are always normalized values between 0..1.  Position: all the values you pass as position coordinates ( x, y ) are from the  upper left corner  of the image or primitive.  Rotation and scale: the values passed for rotation and scaling are considered from the  center  of the image or primitive.", 
            "title": " Graphics"
        }, 
        {
            "location": "/reference/graphics/graphics/#members", 
            "text": "canvas  canvas : object{Canvas}  The basic  canvas  object. Feel free to manipulate it directly to suit your needs.   context  context : object{Canvas2DContext}  read-only   images  images : Array  The list of all the images loaded by Graphics. Useful to have access to the raw ImageElement data.   imagesMap  imagesMap : {}  Same as above, but in form of map.   autoClearScreen  autoClearScreen : Boolean  Flag. When true (which it is, by default), it will clear the screen automatically before drawing. If false, the user will have to do it manually.\nThis is very useful to create several FX as blur (combined with drawing in full screen with low alpha values).", 
            "title": "Members"
        }, 
        {
            "location": "/reference/graphics/graphics/#methods", 
            "text": "init  init (width, height)  Called automatically by Core. No matter how big or small is your game window, you will always have  width,height  pixels in your app.   pixelify  pixelify (flag)  If flag is  true , all the textures will be displayed using nearest filtering. Useful for 8bit/pixelart games.   getWidth  getWidth ()  Return the width of your virtual window (the same value you provided in init). The same as Core.width.   getHeight  getHeight ()  See above and change width by height.   loadImage  loadImage (alias, path)  All images loaded have an alias. The path can be any local image or link.   getImage  getImage (pathOrAlias)  Get an [Image] object previously loaded, using it's path or alias. Better use the alias (it's simpler).   preDraw  preDraw ()  You shouldn't have to touch these two, but in case you need to alter the default drawing of the entire engine: here's the place to do so.   postDraw  postDraw ()   enableBlur  enableBlur (size, r, g, b, a)  Start drawing \"blur\". It will create a blurry halo around everything you draw. It can kill performance.   disableBlur  disableBlur()  Stop using blur.   drawText  drawText (text, x, y, r, g, b, a, size : number, [font=defaultFont] : string)  Example:   Graphics.drawText(\"Hello world!\", 0, 0, 1, 1, 1, 1, 32, \"Arial\");   drawRect  drawRect (x, y, width, height, r, g, b, a, [mode=\"fill\"])  For all the methods that have a \"mode\" parameter, it can always be either  \"fill\"  or  \"stroke\" .   drawFullScreenRect  drawFullScreenRect (r,g,b,a)  Draws a rectangle in fullscreen, no matter where the Camera is.   drawLine  drawLine (x1, y1, x2, y2, r, g, b, a, lineWidth, [round])  If round is not empty, it will be used to define lineCap.   drawArc  drawArc (x, y, radius, startAngle, endAngle, r, g, b, a, lineWidth, [mode=\"fill\"])  Draw an arc. Can be used to draw circles as well, but it is better to use drawCircle instead.   drawCircle  drawCircle (x, y, radius, r, g, b, a, [mode=\"fill\"])   drawSprite  drawSprite (path, x, y, width, height, angle, scaleX, scaleY, alpha)  Path can be the full path to the image or the key used when the asset is loaded.   drawSpriteCropped  drawSpriteCropped (img:[Image], x, y, width, height, angle, scaleX, scaleY, alpha, uvX, uvY, uvW, uvH)  A  cropped  sprite displays a part of the texture defined by its uv in pixels.   drawPolygon  drawPolygon (points : array, x, y, r, g, b, a, [mode=\"fill\"])  The  points  array must have a pair number of elements. Each succesive value is a pair (x,y).   drawRegularPolygon  drawRegularPolygon (x, y, numberOfSides, size, r, g, b, a, [mode=\"fill\"])  A regular polygon is the one which has all sides equally long. From 3 up to infinite.", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/graphics/camera/", 
            "text": "Camera2d\n\n\nSingleton\nClass\n\n\nThe main and only camera singleton. Useful for doing things on the screen, like moving around,\napplying FX (\nshake\n, \nfade-in/out\n or adding an \noverlay tint\n).\n\nNOTE:\n if you want to replace the main camera by one of your own,\njust extend the Camera2d class and then override the Camera object. Easy!\nAnd if you want to set a custom camera of your own, just set the Camera object. \n\n\nMembers\n\n\n\n\nx\n\n\nx : Number\n\n\n\nThe camera's position.\n\n\n\n\ny\n\n\ny : Number\n\n\n\nIdem.\n\n\n\n\nshaking\n\n\nshaking : false\n\n\n\nIf the shake FX is used, this will be true. Don't set to false to stop shaking, use \nstopShake\n instead.\n\n\n\n\nshakeStrength\n\n\nshakeStrength : Number\n\n\n\n\n\nshakeTime\n\n\nshakeTime : Number\n\n\n\n\n\nfading\n\n\nfading : Boolean\n\n\n\nTrue when fading is in progress, false otherwise.\n\n\n\n\noverlayColor\n\n\noverlayColor : {r,g,b,a}\n\n\n\nA color used as full screen overlay. Useful for several FX (including fade in/out).\n\n\n\n\ndrawOverlay\n\n\ndrawOverlay : Boolean\n\n\n\nUseful flag to enable/disable disable drawing the overlay object.\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor ()\n\n\n\n\n\nshake\n\n\nshake (time, strength, onShakeEndCallback)\n\n\n\n\n\nstopShake\n\n\nstopShake ()\n\n\n\n\n\nfade\n\n\nfade ( fromColor {r,g,b,a}, toColor {r,g,b,a}, time, [easing=Utils.E_LINEAR_IN], [fadeEndCallback=Utils.emptyFunc()] )\n\n\n\nExamples:\n\n- fade-out to black: Camera.fade( {0, 0, 0, 0}, {0, 0, 0, 1}, 3.5 )\n- fade-in from white: Camera.fade( {1, 1, 1, 1}, {1, 1, 1, 0}, 3.0 )\n- flash: Camera.fade( {0, 0, 0, 0}, {1, 1, 1, 1}, 0.3, Utils.E_BOUNCE_INOUT ) \n\n\n\n\nupdate\n\n\nupdate ( delta )\n\n\n\n\n\ndraw\n\n\ndraw ()\n\n\n\n\n\ngetX\n\n\ngetX () : number\n\n\n\nGetter for the camera X position. Wraps inside the shake offset, useful to know the accurate position.\n\n\n\n\ngetY\n\n\ngetY () : number\n\n\n\nIdem as above.\n\n\n\n\nsetOverlayColor\n\n\nsetOverlayColor (r, g, b, a)\n\n\n\n\n\nclearOverlayColor\n\n\nclearOverlayColor ()", 
            "title": "Camera"
        }, 
        {
            "location": "/reference/graphics/camera/#camera2d", 
            "text": "Singleton Class  The main and only camera singleton. Useful for doing things on the screen, like moving around,\napplying FX ( shake ,  fade-in/out  or adding an  overlay tint ). NOTE:  if you want to replace the main camera by one of your own,\njust extend the Camera2d class and then override the Camera object. Easy!\nAnd if you want to set a custom camera of your own, just set the Camera object.", 
            "title": " Camera2d"
        }, 
        {
            "location": "/reference/graphics/camera/#members", 
            "text": "x  x : Number  The camera's position.   y  y : Number  Idem.   shaking  shaking : false  If the shake FX is used, this will be true. Don't set to false to stop shaking, use  stopShake  instead.   shakeStrength  shakeStrength : Number   shakeTime  shakeTime : Number   fading  fading : Boolean  True when fading is in progress, false otherwise.   overlayColor  overlayColor : {r,g,b,a}  A color used as full screen overlay. Useful for several FX (including fade in/out).   drawOverlay  drawOverlay : Boolean  Useful flag to enable/disable disable drawing the overlay object.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/graphics/camera/#methods", 
            "text": "constructor  constructor ()   shake  shake (time, strength, onShakeEndCallback)   stopShake  stopShake ()   fade  fade ( fromColor {r,g,b,a}, toColor {r,g,b,a}, time, [easing=Utils.E_LINEAR_IN], [fadeEndCallback=Utils.emptyFunc()] )  Examples: \n- fade-out to black: Camera.fade( {0, 0, 0, 0}, {0, 0, 0, 1}, 3.5 )\n- fade-in from white: Camera.fade( {1, 1, 1, 1}, {1, 1, 1, 0}, 3.0 )\n- flash: Camera.fade( {0, 0, 0, 0}, {1, 1, 1, 1}, 0.3, Utils.E_BOUNCE_INOUT )    update  update ( delta )   draw  draw ()   getX  getX () : number  Getter for the camera X position. Wraps inside the shake offset, useful to know the accurate position.   getY  getY () : number  Idem as above.   setOverlayColor  setOverlayColor (r, g, b, a)   clearOverlayColor  clearOverlayColor ()", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/graphics/sprite/", 
            "text": "Sprite : Entity\n\n\nClass\n \n\n\nThe base drawable object. Sprites are simple, single-texture images. \nYou can draw them normally or \ncropped\n. You can change the [Image] the sprite uses\nin real time, without any flops (\nnote\n: the new image must be loaded as well).\n\n\nSprites are good for making animations (though there is no animation system - yet), \ncharacters, elements from the scene... sprites are for everything. They have basic\nfunctionality for collision detection, however it is a bit shitty.\n\n\n\n\nMembers\n\n\n\n\nimg\n\n\nimg : [Image]\n\n\n\n\n\npath\n\n\npath : String\n\n\n\nIf the sprite was created using the image's path, this will contain the path. \nIf it was created using the alias, this will be its alias.\n\n\n\n\nx\n\n\nx : Number\n\n\n\n\n\ny\n\n\ny : Number\n\n\n\n\n\nwidth\n\n\nwidth : Number\n\n\n\n\n\nheight\n\n\nheight : Number\n\n\n\n\n\nangle\n\n\nangle : Number\n\n\n\n\n\nscale\n\n\nscale : {x, y}\n\n\n\n\n\nuv\n\n\nuv : {u, v, s, t}\n\n\n\n\n\nrect\n\n\nrect : {x, y, w, h}\n\n\n\n\n\nuseBoundingBox\n\n\nuseBoundingBox : Boolean\n\n\n\nWhen true, it will use the bounding box to calculate collisions. When false, it will calculate circle collisions.\n\n\n\n\nradius\n\n\nradius : Number\n\n\n\nUsed for calculation of circle based collisions.\n\n\n\n\ncenter\n\n\ncenter : {x, y}\n\n\n\nUseful both for circle based collisions and to get the image center.\n\n\n\n\nalpha\n\n\nalpha : 1.0\n\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (pathOrAlias)\n\n\n\nThe path or \nalias\n to the already loaded image. \nIt should survive having an empty path (however it won't draw anything).\n\n\n\n\ndraw\n\n\ndraw ()\n\n\n\n\n\ndrawDebug\n\n\ndrawDebug ()\n\n\n\nDisplay the object's bounding area and other info.\n\n\n\n\nupdate\n\n\nupdate (delta)\n\n\n\nOverride to do funny things. Also: this updates the bounding rectangle or circle.\n\n\n\n\nrecalculate\n\n\nrecalculate ()\n\n\n\nForce recalculate the object's bounding area. It is done automatically, \nbut it is useful to force it after changing the image source (for example).\n\n\n\n\nsetSource\n\n\nsetSource (pathOrAlias)\n\n\n\nUse this method to change the current image referenced.\n\n\n\n\nsetUV\n\n\nsetUV (x, y, w, h)\n\n\n\nUV used for cropping.\n\n\n\n\nresetUV\n\n\nresetUV ()\n\n\n\nWhen the UV are resetted, it will point to the default {0, 0, 1, 1} - the full image.\n\n\n\n\ncollides\n\n\ncollides (other : Sprite) : Boolean\n\n\n\nChecks whether this sprite collides with other. Works more accurately when both use\nthe same bounding volume (either both are rectangles or circles).\n\n\n\n\nisPointInRect\n\n\nisPointInRect (x, y)\n\n\n\nDetermine whether the point is inside the bounding rectangle of this sprite.\n\n\n\n\nisPointInCircle\n\n\nisPointInCircle (x, y)\n\n\n\nLike above, but with a circle instead.", 
            "title": "Sprite"
        }, 
        {
            "location": "/reference/graphics/sprite/#sprite-entity", 
            "text": "Class    The base drawable object. Sprites are simple, single-texture images. \nYou can draw them normally or  cropped . You can change the [Image] the sprite uses\nin real time, without any flops ( note : the new image must be loaded as well).  Sprites are good for making animations (though there is no animation system - yet), \ncharacters, elements from the scene... sprites are for everything. They have basic\nfunctionality for collision detection, however it is a bit shitty.", 
            "title": " Sprite : Entity"
        }, 
        {
            "location": "/reference/graphics/sprite/#members", 
            "text": "img  img : [Image]   path  path : String  If the sprite was created using the image's path, this will contain the path. \nIf it was created using the alias, this will be its alias.   x  x : Number   y  y : Number   width  width : Number   height  height : Number   angle  angle : Number   scale  scale : {x, y}   uv  uv : {u, v, s, t}   rect  rect : {x, y, w, h}   useBoundingBox  useBoundingBox : Boolean  When true, it will use the bounding box to calculate collisions. When false, it will calculate circle collisions.   radius  radius : Number  Used for calculation of circle based collisions.   center  center : {x, y}  Useful both for circle based collisions and to get the image center.   alpha  alpha : 1.0", 
            "title": "Members"
        }, 
        {
            "location": "/reference/graphics/sprite/#methods", 
            "text": "constructor  constructor (pathOrAlias)  The path or  alias  to the already loaded image. \nIt should survive having an empty path (however it won't draw anything).   draw  draw ()   drawDebug  drawDebug ()  Display the object's bounding area and other info.   update  update (delta)  Override to do funny things. Also: this updates the bounding rectangle or circle.   recalculate  recalculate ()  Force recalculate the object's bounding area. It is done automatically, \nbut it is useful to force it after changing the image source (for example).   setSource  setSource (pathOrAlias)  Use this method to change the current image referenced.   setUV  setUV (x, y, w, h)  UV used for cropping.   resetUV  resetUV ()  When the UV are resetted, it will point to the default {0, 0, 1, 1} - the full image.   collides  collides (other : Sprite) : Boolean  Checks whether this sprite collides with other. Works more accurately when both use\nthe same bounding volume (either both are rectangles or circles).   isPointInRect  isPointInRect (x, y)  Determine whether the point is inside the bounding rectangle of this sprite.   isPointInCircle  isPointInCircle (x, y)  Like above, but with a circle instead.", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/graphics/atlas/", 
            "text": "Atlas : Sprite\n\n\nClass\n \n\n\nAtlases are good to pack textures together. \nBecause canvas is not very optimized towards this kind of asset repackage, it won't change a lot in terms of\nperformance for your game. However, having atlases is always good, so here you are!\nfunctionality for collision detection, however it is a bit shitty.\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (pathOrAlias)\n\n\n\nThe path or \nalias\n of the already loaded image.\n\n\n\n\ngetImage\n\n\ngetImage (x, y, w, h) : Sprite\n\n\n\nReturn a new up-to-date Sprite with the base texture of the atlas and the provided uv info.\n\n\n\n\ndrawTile\n\n\ndrawTile (x, y, w, h, ux, uy, uw, uh)\n\n\n\nSimple helper for drawing on the screen any part of the texture atlas.", 
            "title": "Atlas"
        }, 
        {
            "location": "/reference/graphics/atlas/#atlas-sprite", 
            "text": "Class    Atlases are good to pack textures together. \nBecause canvas is not very optimized towards this kind of asset repackage, it won't change a lot in terms of\nperformance for your game. However, having atlases is always good, so here you are!\nfunctionality for collision detection, however it is a bit shitty.", 
            "title": " Atlas : Sprite"
        }, 
        {
            "location": "/reference/graphics/atlas/#methods", 
            "text": "constructor  constructor (pathOrAlias)  The path or  alias  of the already loaded image.   getImage  getImage (x, y, w, h) : Sprite  Return a new up-to-date Sprite with the base texture of the atlas and the provided uv info.   drawTile  drawTile (x, y, w, h, ux, uy, uw, uh)  Simple helper for drawing on the screen any part of the texture atlas.", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/graphics/label/", 
            "text": "Label: Sprite\n\n\nClass\n\n\nLabels are just a text sprite. Not like a bitmap font. Just a text. Sprite.\nIt uses the canvas font rendering instead of a more traditional bitmap-font approach.\nDon't forget to manually setup the values for this object!\n\n\nMembers\n\n\n\n\nstr\n\n\nstr : String\n\n\n\n\n\nsize\n\n\nsize : Number\n\n\n\n\n\nr\n\n\nr : Number\n\n\n\n\n\ng\n\n\ng : Number\n\n\n\n\n\nb\n\n\nb : Number\n\n\n\n\n\nfont\n\n\nfont : String\n\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (str)\n\n\n\nThe initial text you would like to see on your label.\n\n\n\n\ndraw\n\n\ndraw ()", 
            "title": "Label"
        }, 
        {
            "location": "/reference/graphics/label/#label-sprite", 
            "text": "Class  Labels are just a text sprite. Not like a bitmap font. Just a text. Sprite.\nIt uses the canvas font rendering instead of a more traditional bitmap-font approach.\nDon't forget to manually setup the values for this object!", 
            "title": " Label: Sprite"
        }, 
        {
            "location": "/reference/graphics/label/#members", 
            "text": "str  str : String   size  size : Number   r  r : Number   g  g : Number   b  b : Number   font  font : String", 
            "title": "Members"
        }, 
        {
            "location": "/reference/graphics/label/#methods", 
            "text": "constructor  constructor (str)  The initial text you would like to see on your label.   draw  draw ()", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/graphics/button/", 
            "text": "Button: Sprite\n\n\nClass\n\n\nClick things that go boom!\n\n\nMembers\n\n\n\n\nonClickFunc\n\n\nonClickFunc : Function\n\n\n\nCallback to execute when the click is performed.\n\n\n\n\ntext\n\n\ntext : Text\n\n\n\nSome text to display.\n\n\n\n\nenabled\n\n\nenabled : Boolean\n\n\n\nIf true, the button will receive input and react to click/touches.    \n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (path, xpos, ypos, myOnClickFunc)\n\n\n\nThe path to the image (already loaded), the position on screen and the callback to execute on click.\n\n\n\n\nsetText\n\n\nsetText (str)\n\n\n\n\n\ndraw\n\n\ndraw ()\n\n\n\n\n\ndrawDebug\n\n\ndrawDebug (r, g, b)\n\n\n\n\n\nonClickInput\n\n\nonClickInput (x, y)\n\n\n\nButtons add themselves to the Input system, and then they get the input.", 
            "title": "Button"
        }, 
        {
            "location": "/reference/graphics/button/#button-sprite", 
            "text": "Class  Click things that go boom!", 
            "title": " Button: Sprite"
        }, 
        {
            "location": "/reference/graphics/button/#members", 
            "text": "onClickFunc  onClickFunc : Function  Callback to execute when the click is performed.   text  text : Text  Some text to display.   enabled  enabled : Boolean  If true, the button will receive input and react to click/touches.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/graphics/button/#methods", 
            "text": "constructor  constructor (path, xpos, ypos, myOnClickFunc)  The path to the image (already loaded), the position on screen and the callback to execute on click.   setText  setText (str)   draw  draw ()   drawDebug  drawDebug (r, g, b)   onClickInput  onClickInput (x, y)  Buttons add themselves to the Input system, and then they get the input.", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/graphics/particlebase/", 
            "text": "ParticleBase : Sprite\n\n\nClass\n\n\nThe ParticleBase class shows how to make a basic and simple particle. \nIts draw method has no body - because you must provide a way to draw them. \nThis is just a very basic physic simulation for a not very impressive particle. \nStill, useful to build on top.\n\n\nMembers\n\n\n\n\nwander\n\n\nwander : Number\n\n\n\nDon't ask me, I'm just passing by here to say hi.\n\n\n\n\ntheta\n\n\ntheta : Number\n\n\n\nAngle.\n\n\n\n\ndrag\n\n\ndrag : Number\n\n\n\nDecceleration of sorts.\n\n\n\n\nvx\n\n\nvx : Number\n\n\n\nSpeed factor for each axis.\n\n\n\n\nvy\n\n\nvy : Number\n\n\n\n\n\nr\n\n\nr : Number\n\n\n\n\n\ng\n\n\ng : Number\n\n\n\n\n\nb\n\n\nb : Number\n\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (path, x, y, radius)\n\n\n\nPath to the image, just in case you want to get fancy.\n\n\n\n\nupdate\n\n\nupdate (delta)\n\n\n\n\n\ndraw\n\n\ndraw ()\n\n\n\n\n\nspawn\n\n\nspawn ()\n\n\n\n\n\nclone\n\n\nclone ()", 
            "title": "Pariclebase"
        }, 
        {
            "location": "/reference/graphics/particlebase/#particlebase-sprite", 
            "text": "Class  The ParticleBase class shows how to make a basic and simple particle. \nIts draw method has no body - because you must provide a way to draw them. \nThis is just a very basic physic simulation for a not very impressive particle. \nStill, useful to build on top.", 
            "title": " ParticleBase : Sprite"
        }, 
        {
            "location": "/reference/graphics/particlebase/#members", 
            "text": "wander  wander : Number  Don't ask me, I'm just passing by here to say hi.   theta  theta : Number  Angle.   drag  drag : Number  Decceleration of sorts.   vx  vx : Number  Speed factor for each axis.   vy  vy : Number   r  r : Number   g  g : Number   b  b : Number", 
            "title": "Members"
        }, 
        {
            "location": "/reference/graphics/particlebase/#methods", 
            "text": "constructor  constructor (path, x, y, radius)  Path to the image, just in case you want to get fancy.   update  update (delta)   draw  draw ()   spawn  spawn ()   clone  clone ()", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/graphics/particlecircle/", 
            "text": "ParticleCircle : ParticleBase\n\n\nClass\n\n\nAn small sample about how to extend the ParticleBase and provide a render method.\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (path, x, y, radius)\n\n\n\n\n\ndraw\n\n\ndraw ()", 
            "title": "ParticleCircle"
        }, 
        {
            "location": "/reference/graphics/particlecircle/#particlecircle-particlebase", 
            "text": "Class  An small sample about how to extend the ParticleBase and provide a render method.", 
            "title": " ParticleCircle : ParticleBase"
        }, 
        {
            "location": "/reference/graphics/particlecircle/#methods", 
            "text": "constructor  constructor (path, x, y, radius)   draw  draw ()", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/graphics/particlesystem/", 
            "text": "ParticleSystem : Pool\n\n\nClass\n\n\nThe ParticleSystem is the class controlling a bunch of particles: it decides how, when and how many particles spawn. \nActually, that's you.\nAs you see, the ParticleSystem is a Pool object, in order to reuse the same particles as much as possible.\n\nIMPORTANT\n: remember adding a base object to pool (\naddToPool\n) BEFORE spawning. Just like any other pool.\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor ()\n\n\n\n\n\nspawn\n\n\nspawn (x, y, amount)", 
            "title": "ParticleSystem"
        }, 
        {
            "location": "/reference/graphics/particlesystem/#particlesystem-pool", 
            "text": "Class  The ParticleSystem is the class controlling a bunch of particles: it decides how, when and how many particles spawn. \nActually, that's you.\nAs you see, the ParticleSystem is a Pool object, in order to reuse the same particles as much as possible. IMPORTANT : remember adding a base object to pool ( addToPool ) BEFORE spawning. Just like any other pool.", 
            "title": " ParticleSystem : Pool"
        }, 
        {
            "location": "/reference/graphics/particlesystem/#methods", 
            "text": "constructor  constructor ()   spawn  spawn (x, y, amount)", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/physics/physics/", 
            "text": "Physics : Entity\n\n\nSingleton\n\n\nAn extremely simple yet effective way to handle collision detection and response.\nThis system provides support for 2d circles and squares with mass, friction, velocity and other paramenters.\nSuitable for top down or platformer games. If you need more advanced features, check the hello_matterjs sample.\nThere are no speed up structures (quadtree or similar), which means this can become slow when too many objects\nare in the simulation. Try to keep them to a minimum.\n\n\nIMPORTANT\n: this is a somewhat \"external\" module. If you want to use this physics module, you will have to add\nthe \nPhysics\n entity to your gamestates by doing: \nthis.add(Physics)\n \nor\n by doing Physics.update(delta).\n\n\n\n\nMembers\n\n\n\n\ngravity\n\n\ngravity : { x: 0, y: -10 }\n\n\n\nThe simulation gravity.\n\n\n\n\nbodies\n\n\nbodies : Array\n\n\n\nThe \nBodies\n in the simulation.\n\n\n\n\nV_AABB\n\n\nV_AABB\n\n\n\nread-only\n\n\nA constant used to define an axis aligned bounding box type object.\n\n\n\n\nV_SPHERE\n\n\nV_SPHERE\n\n\n\nThe same as V_AABB, but for bounding circles.\n\n\n\n\nMethods\n\n\n\n\naddBody\n\n\naddBody (body)\n\n\n\nMethod used internally by \nBody\n. You can call it manually to add a new Body to the simulation\n(in case you don't want to use \nPhysics.newBody\n).\n\n\n\n\nnewBody\n\n\nnewBody (group)\n\n\n\nMain entry point. Use to get a new Body in your simulation.\n\n\n\n\nremoveBody\n\n\nremoveBody (body)\n\n\n\nIf the body exists, it will be removed from the simulation.\n\n\n\n\nsetGravity\n\n\nsetGravity (x, y)\n\n\n\n\n\ntestAABBvsAABB\n\n\ntestAABBvsAABB (first, second)\n\n\n\nTest method to determine whether 2 AABB collide. The returned object will contain 3 fields:\n- result (true or false)\n- thisObj {x,y} (an object with the position of the collision for \nfirst\n)\n- otherObj {x,y} (an object with the position of the collision for \nsecond\n)\n\n\n\n\ntestSPHEREvsSPHERE\n\n\ntestSPHEREvsSPHERE (first, second)\n\n\n\nTest method to determine whether 2 circles collide. The returned object is the same like in testAABBvsAABB.\n\n\n\n\ntestAABBvsSPHERE\n\n\ntestAABBvsSPHERE (first, second)\n\n\n\nA fake circle vs aabb test: it will check the collision between the sphere but converted as aabb.\n\n\n\n\nupdate\n\n\nupdate (delta)\n\n\n\nAll the collisions are handled here, so you \nmust\n remember to either add Physics to your gamestates or call this method manually.", 
            "title": "Physics"
        }, 
        {
            "location": "/reference/physics/physics/#physics-entity", 
            "text": "Singleton  An extremely simple yet effective way to handle collision detection and response.\nThis system provides support for 2d circles and squares with mass, friction, velocity and other paramenters.\nSuitable for top down or platformer games. If you need more advanced features, check the hello_matterjs sample.\nThere are no speed up structures (quadtree or similar), which means this can become slow when too many objects\nare in the simulation. Try to keep them to a minimum.  IMPORTANT : this is a somewhat \"external\" module. If you want to use this physics module, you will have to add\nthe  Physics  entity to your gamestates by doing:  this.add(Physics)   or  by doing Physics.update(delta).", 
            "title": " Physics : Entity"
        }, 
        {
            "location": "/reference/physics/physics/#members", 
            "text": "gravity  gravity : { x: 0, y: -10 }  The simulation gravity.   bodies  bodies : Array  The  Bodies  in the simulation.   V_AABB  V_AABB  read-only  A constant used to define an axis aligned bounding box type object.   V_SPHERE  V_SPHERE  The same as V_AABB, but for bounding circles.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/physics/physics/#methods", 
            "text": "addBody  addBody (body)  Method used internally by  Body . You can call it manually to add a new Body to the simulation\n(in case you don't want to use  Physics.newBody ).   newBody  newBody (group)  Main entry point. Use to get a new Body in your simulation.   removeBody  removeBody (body)  If the body exists, it will be removed from the simulation.   setGravity  setGravity (x, y)   testAABBvsAABB  testAABBvsAABB (first, second)  Test method to determine whether 2 AABB collide. The returned object will contain 3 fields:\n- result (true or false)\n- thisObj {x,y} (an object with the position of the collision for  first )\n- otherObj {x,y} (an object with the position of the collision for  second )   testSPHEREvsSPHERE  testSPHEREvsSPHERE (first, second)  Test method to determine whether 2 circles collide. The returned object is the same like in testAABBvsAABB.   testAABBvsSPHERE  testAABBvsSPHERE (first, second)  A fake circle vs aabb test: it will check the collision between the sphere but converted as aabb.   update  update (delta)  All the collisions are handled here, so you  must  remember to either add Physics to your gamestates or call this method manually.", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/physics/body/", 
            "text": "Body : Entity\n\n\nClass\n\n\nA very simple 2d \"rigid\" body.\n\n\nWhile the physics system presented in micron is extremely simple (there are no joints for example nor rotations),\neach body behaves as a rigid body. It can be \nsolid\n (things collide with it) or \ndynamic\n (forces affect it, like velocity\nor collisions with other objects). Non solid objects will be moved through others, and non dynamic cannot react to forces (like\nvelocity or gravity).\n\n\nFurthermore, each object belongs to a given \"collision group\". Each object can set one callback to interact with each different\ngroup, and it is possible to set a collision with its own group. Whether the object is solid/passable, dynamic/static, the callback\nwill be triggered. It is also possible to skip groups to avoid all callbacks and collision info whatsoever.\n\n\nSetting the \nvelocity\n manually works, as well as using \naddImpulse*. However the latter uses the mass. \nFriction\n is used both\nfor \"air friction\" and friction against objects (for now). \nElasticity\n controls how much \"bounciness\" an object has when colliding\nwith another. \nMass** is also important to determine how much objects bounce with each other.\n\n\n\n\nMembers\n\n\n\n\ngroup\n\n\ngroup : String\n\n\n\n\"default\" is the default value.\n\n\n\n\ntype\n\n\ntype\n\n\n\nV_AABB by default (a rectangle).\n\n\n\n\nx\n\n\nx : Number\n\n\n\nThe position of the body.\n\n\nWARNING\n: in the physics module, the position is \nAT THE CENTER OF THE OBJECT\n, and not the top left corner.\n\n\n\n\ny\n\n\ny : Number\n\n\n\nIdem above.\n\n\n\n\nw\n\n\nw : Number\n\n\n\nWidth of the object. Used for AABB vs AABB and AABB vs Circle.\n\n\n\n\nh\n\n\nh : Number\n\n\n\nHeight of the object.\n\n\n\n\nextents\n\n\nextents : { x: 0.5, y: 0.5 }\n\n\n\nHalf the size in each axis.\n\n\n\n\nradius\n\n\nradius : Number\n\n\n\nUsed only when type === V_SPHERE.\n\n\n\n\nmass\n\n\nmass : Number\n\n\n\n\n\nelasticity\n\n\nelasticity : Number\n\n\n\n1.0 or bigger means a very \"jumpy\" object. Less than 1.0 means a less \"reactive\" object.\n\n\n\n\nfriction\n\n\nfriction : Number\n\n\n\nUse wisely to control velocity decay (\"air friction\"), and friction against other objects.\n\n\n\n\nvelocity\n\n\nvelocity : { x: 0, y:0 }\n\n\n\n\n\nisDynamic\n\n\nisDynamic : Boolean\n\n\n\nWhen true, the object reacts to forces (like gravity and impulses). When false, it will stay in place unmovable.\n\n\n\n\nisSolid\n\n\nisSolid : Boolean\n\n\n\nSolid objects can collide with others. Non solid objects are passable. Either way, onCollision callbacks are always triggered, even when non solid.\n\n\n\n\nskippedGroups\n\n\nskippedGroups : Array\n\n\n\nList of all skippable groups (all objects of those groups won't trigger collision nor callbacks).\n\n\n\n\ngroupsOnCallbacks\n\n\ngroupsOnCallbacks : Map\n\n\n\nAn internal map used to hold all the callbacks for this object.\n\n\n\n\nMethods\n\n\n\n\nconstructor ()\n\n\nconstructor (group)\n\n\n\n\n\ndestroy\n\n\ndestroy ()\n\n\n\nEither this method has to be called in the body to release it inside Physics, or Physics.removeBody(this).\n\n\n\n\nmakeCircle\n\n\nmakeCircle (x, y, radius)\n\n\n\nHelper to quickly create a circular shaped body.\n\n\n\n\nmakeRect\n\n\nmakeRect (x, y, w, h)\n\n\n\nHelper to quickly create a rectangular shaped body. Note that rectangle is the shape by default.\n\n\n\n\nsetPosition\n\n\nsetPosition (x, y)\n\n\n\n\n\nsetSize\n\n\nsetSize (w, h)\n\n\n\n\n\nsetRadius\n\n\nsetRadius (r)\n\n\n\n\n\nskipGroup\n\n\nskipGroup (otherGroup)\n\n\n\nMark \notherGroup\n as skippable.\n\n\n\n\nskipSelfGroup\n\n\nskipSelfGroup (flag)\n\n\n\nMark the own group as skippable (for example, avoid entirely collisions between walls in a map).\n\n\n\n\nunskipGroup\n\n\nunskipGroup (otherGroup)\n\n\n\nRemove \notherGroup\n from the list of skippable objects.\n\n\n\n\ncanSkip\n\n\ncanSkip (otherGroup)\n\n\n\nReturns \ntrue\n if the other group can be skipped. False otherwise.\n\n\n\n\nonCollision\n\n\nonCollision (group, callback)\n\n\n\nSetter for a \ncallback\n against the given \ngroup\n.\nExample: \nthis.onCollision(\"coin\", this.onGetCoin.bind(this));\n\n\n\n\nintersects\n\n\nintersects (other)\n\n\n\nReturns \ncollision data\n after checking if there is an intersection with \nother\n.\n\n\n\n\nprocessCollision\n\n\nprocessCollision (other, data)\n\n\n\nGiven the other object and the intersection data, this method calculates the new positions and forces for both of them.    \n\n\n\n\nexecCallback\n\n\nexecCallback (other)\n\n\n\nExecute the callback for the group of the \nother\n object.\n\n\n\n\nisPointInside\n\n\nisPointInside (x, y)\n\n\n\nReturns whether the given point is inside the Body.\n\n\n\n\naddImpulse\n\n\naddImpulse (x, y)\n\n\n\nAdd an ongoing impulse in the direction provided by the vector (x, y). This vector will be divided by this object's \nmass\n.\nNote that a similar effect can be achieved by setting the velocity directly.\n\n\n\n\nresetVelocity\n\n\nresetVelocity ()\n\n\n\n\n\nupdate\n\n\nupdate (delta)\n\n\n\nIf the object is not dynamic, there is no need to update. However it is recommended. If the object was added to Physics, this will be done automatically.    \n\n\n\n\ndrawDebug\n\n\ndrawDebug (r, g, b, a)", 
            "title": "Body"
        }, 
        {
            "location": "/reference/physics/body/#body-entity", 
            "text": "Class  A very simple 2d \"rigid\" body.  While the physics system presented in micron is extremely simple (there are no joints for example nor rotations),\neach body behaves as a rigid body. It can be  solid  (things collide with it) or  dynamic  (forces affect it, like velocity\nor collisions with other objects). Non solid objects will be moved through others, and non dynamic cannot react to forces (like\nvelocity or gravity).  Furthermore, each object belongs to a given \"collision group\". Each object can set one callback to interact with each different\ngroup, and it is possible to set a collision with its own group. Whether the object is solid/passable, dynamic/static, the callback\nwill be triggered. It is also possible to skip groups to avoid all callbacks and collision info whatsoever.  Setting the  velocity  manually works, as well as using  addImpulse*. However the latter uses the mass.  Friction  is used both\nfor \"air friction\" and friction against objects (for now).  Elasticity  controls how much \"bounciness\" an object has when colliding\nwith another.  Mass** is also important to determine how much objects bounce with each other.", 
            "title": " Body : Entity"
        }, 
        {
            "location": "/reference/physics/body/#members", 
            "text": "group  group : String  \"default\" is the default value.   type  type  V_AABB by default (a rectangle).   x  x : Number  The position of the body.  WARNING : in the physics module, the position is  AT THE CENTER OF THE OBJECT , and not the top left corner.   y  y : Number  Idem above.   w  w : Number  Width of the object. Used for AABB vs AABB and AABB vs Circle.   h  h : Number  Height of the object.   extents  extents : { x: 0.5, y: 0.5 }  Half the size in each axis.   radius  radius : Number  Used only when type === V_SPHERE.   mass  mass : Number   elasticity  elasticity : Number  1.0 or bigger means a very \"jumpy\" object. Less than 1.0 means a less \"reactive\" object.   friction  friction : Number  Use wisely to control velocity decay (\"air friction\"), and friction against other objects.   velocity  velocity : { x: 0, y:0 }   isDynamic  isDynamic : Boolean  When true, the object reacts to forces (like gravity and impulses). When false, it will stay in place unmovable.   isSolid  isSolid : Boolean  Solid objects can collide with others. Non solid objects are passable. Either way, onCollision callbacks are always triggered, even when non solid.   skippedGroups  skippedGroups : Array  List of all skippable groups (all objects of those groups won't trigger collision nor callbacks).   groupsOnCallbacks  groupsOnCallbacks : Map  An internal map used to hold all the callbacks for this object.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/physics/body/#methods", 
            "text": "constructor ()  constructor (group)   destroy  destroy ()  Either this method has to be called in the body to release it inside Physics, or Physics.removeBody(this).   makeCircle  makeCircle (x, y, radius)  Helper to quickly create a circular shaped body.   makeRect  makeRect (x, y, w, h)  Helper to quickly create a rectangular shaped body. Note that rectangle is the shape by default.   setPosition  setPosition (x, y)   setSize  setSize (w, h)   setRadius  setRadius (r)   skipGroup  skipGroup (otherGroup)  Mark  otherGroup  as skippable.   skipSelfGroup  skipSelfGroup (flag)  Mark the own group as skippable (for example, avoid entirely collisions between walls in a map).   unskipGroup  unskipGroup (otherGroup)  Remove  otherGroup  from the list of skippable objects.   canSkip  canSkip (otherGroup)  Returns  true  if the other group can be skipped. False otherwise.   onCollision  onCollision (group, callback)  Setter for a  callback  against the given  group .\nExample:  this.onCollision(\"coin\", this.onGetCoin.bind(this));   intersects  intersects (other)  Returns  collision data  after checking if there is an intersection with  other .   processCollision  processCollision (other, data)  Given the other object and the intersection data, this method calculates the new positions and forces for both of them.       execCallback  execCallback (other)  Execute the callback for the group of the  other  object.   isPointInside  isPointInside (x, y)  Returns whether the given point is inside the Body.   addImpulse  addImpulse (x, y)  Add an ongoing impulse in the direction provided by the vector (x, y). This vector will be divided by this object's  mass .\nNote that a similar effect can be achieved by setting the velocity directly.   resetVelocity  resetVelocity ()   update  update (delta)  If the object is not dynamic, there is no need to update. However it is recommended. If the object was added to Physics, this will be done automatically.       drawDebug  drawDebug (r, g, b, a)", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/animation/animkey/", 
            "text": "AnimKey: TweenObject\n\n\nClass\n\n\nAn AnimKey is basically a data value for a keyframe. It can store any kind of value\nfor any kind of property. You can pass in an easing function to define how the property\nwill be tweened (if easing is enabled for the animation).\n\n\nMembers\n\n\n\n\nstopTime\n\n\nstopTime : Number\n\n\n\nThe time at which the keyframe will end.\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (obj : String, startTime : Number, stopTime : Number, property : Number, value : Number, [easing])\n\n\n\nA quite complex key for a frame. Actually, it is not a single frame but rather a\nduration in time between startTime and stopTime.\n\n\n\n\nobj: the actor name upon we will do things\n\n\nstartTime: the time at which this key will start\n\n\nstopTime: the time at which this key will stop (if easing)\n\n\nproperty: what we will be changing. String, since this is a name too.\n\n\nvalue: the destination value the property will have. This has to match the actual property type you target.\n\n\neasing: any easing function to use (if easing). Check Utils.", 
            "title": "AnimKey"
        }, 
        {
            "location": "/reference/animation/animkey/#animkey-tweenobject", 
            "text": "Class  An AnimKey is basically a data value for a keyframe. It can store any kind of value\nfor any kind of property. You can pass in an easing function to define how the property\nwill be tweened (if easing is enabled for the animation).", 
            "title": " AnimKey: TweenObject"
        }, 
        {
            "location": "/reference/animation/animkey/#members", 
            "text": "stopTime  stopTime : Number  The time at which the keyframe will end.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/animation/animkey/#methods", 
            "text": "constructor  constructor (obj : String, startTime : Number, stopTime : Number, property : Number, value : Number, [easing])  A quite complex key for a frame. Actually, it is not a single frame but rather a\nduration in time between startTime and stopTime.   obj: the actor name upon we will do things  startTime: the time at which this key will start  stopTime: the time at which this key will stop (if easing)  property: what we will be changing. String, since this is a name too.  value: the destination value the property will have. This has to match the actual property type you target.  easing: any easing function to use (if easing). Check Utils.", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/animation/animkeycall/", 
            "text": "AnimKeyCall: Base\n\n\nClass\n\n\nIf AnimKey is a basic data value for a keyframe duration, an AnimKeyCall is a holder for a function callback.\nThis type of keyframe value basically calls a function of any object you put as an actor and passes the parameters.\nThis is very powerful and allows you to do real animation based logic: for example, the type of thing you could see\non a game like Infinity Blade. In fact this is so powerful, that you can do an spritesheet animation based with this\njust calling setUV and changing the proper values. Magic.\n\n\nMembers\n\n\n\n\nfunc\n\n\nfunc : Function\n\n\n\nThe function callback.\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (obj : String, time : Number, func : Function, params : Array)\n\n\n\nA quite simple key for calling any method of any of your actors.\n\n\n\n\nobj: the actor name\n\n\ntime: the time to trigger the call\n\n\nfunc: the function callback we will execute\n\n\nparams: extra magic, an array. The array can hold any data that your function accepts as parameters.\n\n\n\n\n\n\nexec\n\n\nexec : (who)\n\n\n\n\"Who\" is any object or class you use as your \"actor\". This basically performs a call\non that object for the given method this key is holding.\n\n\nWARNING: There are no error checking things here, be careful.", 
            "title": "AnimKeyCall"
        }, 
        {
            "location": "/reference/animation/animkeycall/#animkeycall-base", 
            "text": "Class  If AnimKey is a basic data value for a keyframe duration, an AnimKeyCall is a holder for a function callback.\nThis type of keyframe value basically calls a function of any object you put as an actor and passes the parameters.\nThis is very powerful and allows you to do real animation based logic: for example, the type of thing you could see\non a game like Infinity Blade. In fact this is so powerful, that you can do an spritesheet animation based with this\njust calling setUV and changing the proper values. Magic.", 
            "title": " AnimKeyCall: Base"
        }, 
        {
            "location": "/reference/animation/animkeycall/#members", 
            "text": "func  func : Function  The function callback.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/animation/animkeycall/#methods", 
            "text": "constructor  constructor (obj : String, time : Number, func : Function, params : Array)  A quite simple key for calling any method of any of your actors.   obj: the actor name  time: the time to trigger the call  func: the function callback we will execute  params: extra magic, an array. The array can hold any data that your function accepts as parameters.    exec  exec : (who)  \"Who\" is any object or class you use as your \"actor\". This basically performs a call\non that object for the given method this key is holding.  WARNING: There are no error checking things here, be careful.", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/animation/animclip/", 
            "text": "AnimClip: Base\n\n\nClass\n\n\nAn AnimClip is a single animation: a collection of keyframes. This keyframes are just\nduration values wrapping something that happens to objects: can be done using easing or not.\nCan be a value of a property, or a callback to function. A single animation clip can contain\nthe data for a single animation, ie. \"walking\", \"dying\", etc.\n\n\nNote that the actor defined here is always an string (an id, a name) to make the animclips\n\nreusable\n by other entities. This way, the animator can define a new object for the actor\nand still use the data of another actor/entity/object.\n\n\nIn short: one clip is a single animation. It can animate any object or actor passed and\ncan have any number of keyframes. Keyframes can be mixed and disordered in its definition (you can\nmix them up and they will be played still properly following the time they should trigger at).\nFrames can define custom easing functions and you can add AnimKey's or AnimKeyCall's.\n\n\nMembers\n\n\n\n\nname\n\n\nname : String\n\n\n\nThe name of the animation.\n\n\n\n\nloop\n\n\nloop : Boolean\n\n\n\nWheather or not the animation will be looped.\n\n\n\n\nease\n\n\nease : Boolean\n\n\n\nWhen true, the frames will be eased using the defined easing function for each one.\nWhen false, the frames will not be eased and just \"jump\" from one to the next.\nAnimKeyCalls are never eased (it just makes no sense. Think about it).\n\n\n\n\nframes\n\n\nframes : Array\n\n\n\nEach one and all of the frames for this clip. Have fun messing with it!\n\n\n\n\ncurrentTime\n\n\ncurrentTime : Number\n\n\n\nI have no idea why you would want to mess with the current playback time, but here you go.\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor : function(name : String, loop : Boolean, ease : Boolean)\n\n\n\n\n\naddKey\n\n\naddKey : function(actor : String, startTime : Number, stopTime : Number, property : String, value : Number, [easing])\n\n\n\nAdd a new keyframe to this animation clip.  The time is in seconds. For easing functions, check Utils.\n\n\n\n\naddKeyCall\n\n\naddKeyCall : function(actor : String, time : Number, func : Function, params : Array)\n\n\n\nAdd a new keyframe function callback. The time is in seconds, the function should not be empty and the array should contain\nthe actual parameter values for the callback.\n\n\nWARNING: we do not check things here. If the function is empty or the things passed to the function are not ok, it is your fault ;)\n\n\n\n\nremoveKeys\n\n\nremoveKeys : function(startTime)\n\n\n\nTODO\n\n\n\n\nrun\n\n\nrun : function(delta)\n\n\n\nUsed internally by the animator. You should never need it, but...\n\n\n\n\nreset\n\n\nreset : function()\n\n\n\nAlso used internally by the animator.", 
            "title": "AnimClip"
        }, 
        {
            "location": "/reference/animation/animclip/#animclip-base", 
            "text": "Class  An AnimClip is a single animation: a collection of keyframes. This keyframes are just\nduration values wrapping something that happens to objects: can be done using easing or not.\nCan be a value of a property, or a callback to function. A single animation clip can contain\nthe data for a single animation, ie. \"walking\", \"dying\", etc.  Note that the actor defined here is always an string (an id, a name) to make the animclips reusable  by other entities. This way, the animator can define a new object for the actor\nand still use the data of another actor/entity/object.  In short: one clip is a single animation. It can animate any object or actor passed and\ncan have any number of keyframes. Keyframes can be mixed and disordered in its definition (you can\nmix them up and they will be played still properly following the time they should trigger at).\nFrames can define custom easing functions and you can add AnimKey's or AnimKeyCall's.", 
            "title": " AnimClip: Base"
        }, 
        {
            "location": "/reference/animation/animclip/#members", 
            "text": "name  name : String  The name of the animation.   loop  loop : Boolean  Wheather or not the animation will be looped.   ease  ease : Boolean  When true, the frames will be eased using the defined easing function for each one.\nWhen false, the frames will not be eased and just \"jump\" from one to the next.\nAnimKeyCalls are never eased (it just makes no sense. Think about it).   frames  frames : Array  Each one and all of the frames for this clip. Have fun messing with it!   currentTime  currentTime : Number  I have no idea why you would want to mess with the current playback time, but here you go.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/animation/animclip/#methods", 
            "text": "constructor  constructor : function(name : String, loop : Boolean, ease : Boolean)   addKey  addKey : function(actor : String, startTime : Number, stopTime : Number, property : String, value : Number, [easing])  Add a new keyframe to this animation clip.  The time is in seconds. For easing functions, check Utils.   addKeyCall  addKeyCall : function(actor : String, time : Number, func : Function, params : Array)  Add a new keyframe function callback. The time is in seconds, the function should not be empty and the array should contain\nthe actual parameter values for the callback.  WARNING: we do not check things here. If the function is empty or the things passed to the function are not ok, it is your fault ;)   removeKeys  removeKeys : function(startTime)  TODO   run  run : function(delta)  Used internally by the animator. You should never need it, but...   reset  reset : function()  Also used internally by the animator.", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/animation/animator/", 
            "text": "Animator: Entity\n\n\nClass\n\n\nThe animator is the class responsible for the actual animation: you need this one to \nplay/pause/stop clips. You can have as many animators as you want, but shouldn't have \nmore than one per entity. When adding AnimClips to the animator, the animator itself\nsets as the father of the clips. If you try to animate the clips without an animator, \nit will fail because it is the animator the one that has the link actor \n object.\n\n\nIMPORTANT: you need to manually update it, or just do this.add(this_animator) to your \nentity/state/whatever.\n\n\nMembers\n\n\n\n\nplaying\n\n\nplaying : Boolean\n\n\n\nA nice flag to know whether this animator is playing an animation or not.\n\n\n\n\npaused\n\n\npaused : Boolean\n\n\n\nAnother helpful flag to know whether the animator is paused or not. Kinda redundant, isn't it?\n\n\n\n\nclips\n\n\nclips : Array\n\n\n\nThis array (holding simple objects actually) stores the information of the actors for each clip.\nThis means that if you want to dynamically change the actors for a clip, this is where you can do it.\n\n\nNOTE: at some point there will be functions to mess with this properly.\n\n\nEach clip is an object of the form { clip: AnimClip, actors: Map } where the actors map is of the form:\n{ \"actorName\" : actorObject, \"anotherActor\" : anotherObject, ... }\n\n\n\n\ncurrentAnim\n\n\ncurrentAnim : String\n\n\n\nThe name of the current animation player. \n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor : function()\n\n\n\n\n\naddClip\n\n\naddClip : function(animClip : AnimationClip, actorsMap : Map)\n\n\n\nAdd a new clip to the animator object. Example:\n\n\n`this.animator.addClip(this.ninjaAnimationRun, { \"actor\" : this.ninjaObject } );`\n\n\n\n\n\nremove\n\n\nremove : function(animClip)\n\n\n\nRemove a clip by its reference. Should be useful to remove by name. Will be done, some day. \n\n\n\n\nremoveAll\n\n\nremoveAll : function()\n\n\n\nRemove all clips. And obviusly stops animations.\n\n\n\n\ngetActor\n\n\ngetActor : function(actorName : String)\n\n\n\nThe Animator is the actual piece of the puzzle that knows which \"actors\" must be updated for the animation.\nSo... this will return you whatever you put in the actors map under the given \"actorName\" string.\n\n\nWARNING: if no actor is found, it will return null. Be careful with it pretty please.\n\n\n\n\nonActorUpdate\n\n\nonActorUpdate : function(actor : String, property : String, value : Number)\n\n\n\nWhen easing is disabled, the frame data is passed to the actor through the animator. That is what this function\nis for. You shouldn't be messing with it, but just in case you need it. \n\n\nNOTE: when easing is enabled, the values are modified directly on the actor object itself (the tween has a \nreference to the actor to save time).\n\n\n\n\nplay\n\n\nplay : function(name : String)\n\n\n\nPlay the given animation clip. Note that when doing play, it will reset the animation.\n\n\nWARNING: there is no error check, so if you pass a non existant name, it might likely crash. Yeah.\n\n\n\n\npause\n\n\npause : function()\n\n\n\nPause and unpause the animation. If you pause it and want to resume it, use this please. \nUsing play will reset the animation.    \n\n\n\n\nstop\n\n\nstop : function()\n\n\n\nStop the current playback of the animation. Resuming via play will obviously start from the beginning.\nResuming via pause will not restart the animation obviously, but might keep it paused (so you can actually\npause it before start, to start paused).", 
            "title": "Animator"
        }, 
        {
            "location": "/reference/animation/animator/#animator-entity", 
            "text": "Class  The animator is the class responsible for the actual animation: you need this one to \nplay/pause/stop clips. You can have as many animators as you want, but shouldn't have \nmore than one per entity. When adding AnimClips to the animator, the animator itself\nsets as the father of the clips. If you try to animate the clips without an animator, \nit will fail because it is the animator the one that has the link actor   object.  IMPORTANT: you need to manually update it, or just do this.add(this_animator) to your \nentity/state/whatever.", 
            "title": " Animator: Entity"
        }, 
        {
            "location": "/reference/animation/animator/#members", 
            "text": "playing  playing : Boolean  A nice flag to know whether this animator is playing an animation or not.   paused  paused : Boolean  Another helpful flag to know whether the animator is paused or not. Kinda redundant, isn't it?   clips  clips : Array  This array (holding simple objects actually) stores the information of the actors for each clip.\nThis means that if you want to dynamically change the actors for a clip, this is where you can do it.  NOTE: at some point there will be functions to mess with this properly.  Each clip is an object of the form { clip: AnimClip, actors: Map } where the actors map is of the form:\n{ \"actorName\" : actorObject, \"anotherActor\" : anotherObject, ... }   currentAnim  currentAnim : String  The name of the current animation player.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/animation/animator/#methods", 
            "text": "constructor  constructor : function()   addClip  addClip : function(animClip : AnimationClip, actorsMap : Map)  Add a new clip to the animator object. Example:  `this.animator.addClip(this.ninjaAnimationRun, { \"actor\" : this.ninjaObject } );`   remove  remove : function(animClip)  Remove a clip by its reference. Should be useful to remove by name. Will be done, some day.    removeAll  removeAll : function()  Remove all clips. And obviusly stops animations.   getActor  getActor : function(actorName : String)  The Animator is the actual piece of the puzzle that knows which \"actors\" must be updated for the animation.\nSo... this will return you whatever you put in the actors map under the given \"actorName\" string.  WARNING: if no actor is found, it will return null. Be careful with it pretty please.   onActorUpdate  onActorUpdate : function(actor : String, property : String, value : Number)  When easing is disabled, the frame data is passed to the actor through the animator. That is what this function\nis for. You shouldn't be messing with it, but just in case you need it.   NOTE: when easing is enabled, the values are modified directly on the actor object itself (the tween has a \nreference to the actor to save time).   play  play : function(name : String)  Play the given animation clip. Note that when doing play, it will reset the animation.  WARNING: there is no error check, so if you pass a non existant name, it might likely crash. Yeah.   pause  pause : function()  Pause and unpause the animation. If you pause it and want to resume it, use this please. \nUsing play will reset the animation.       stop  stop : function()  Stop the current playback of the animation. Resuming via play will obviously start from the beginning.\nResuming via pause will not restart the animation obviously, but might keep it paused (so you can actually\npause it before start, to start paused).", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/sound/sound/", 
            "text": "Sound\n\n\nSingleton\n\n\nThe biggest module of Micron by far. Understanding its inner workings grant you access to the Nirvana for 2 weeks.\n\n\nMethods\n\n\n\n\nhasSound\n\n\nhasSound () : Boolean\n\n\n\nReturns true if the browser supports sound. Yeah.", 
            "title": "Sound"
        }, 
        {
            "location": "/reference/sound/sound/#sound", 
            "text": "Singleton  The biggest module of Micron by far. Understanding its inner workings grant you access to the Nirvana for 2 weeks.", 
            "title": " Sound"
        }, 
        {
            "location": "/reference/sound/sound/#methods", 
            "text": "hasSound  hasSound () : Boolean  Returns true if the browser supports sound. Yeah.", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/sound/song/", 
            "text": "Song : Base\n\n\nClass\n \n\n\nUnlike with Sound, this actually has something inside.\nAlso, this is like the shittiest name ever made. But hey, Audio was picked, so, what can we do?\n\n\nMembers\n\n\n\n\npath\n\n\npath : String\n\n\n\nThe path to your audio file.\n\n\n\n\nloops\n\n\nloops : Boolean\n\n\n\nWhen true, it will keep looping until the end of days.\n\n\n\n\nMethods\n\n\n\n\nconstructor\n\n\nconstructor (path, loop)\n\n\n\nPath: an string, path to your sound. Loop: boolean flag. True to make it loop.\n\n\n\n\nplay\n\n\nplay ()\n\n\n\n\n\npause\n\n\npause ()\n\n\n\n\n\nstop\n\n\nstop ()\n\n\n\n\n\nsetVolume\n\n\nsetVolume (value)", 
            "title": "Song"
        }, 
        {
            "location": "/reference/sound/song/#song-base", 
            "text": "Class    Unlike with Sound, this actually has something inside.\nAlso, this is like the shittiest name ever made. But hey, Audio was picked, so, what can we do?", 
            "title": " Song : Base"
        }, 
        {
            "location": "/reference/sound/song/#members", 
            "text": "path  path : String  The path to your audio file.   loops  loops : Boolean  When true, it will keep looping until the end of days.", 
            "title": "Members"
        }, 
        {
            "location": "/reference/sound/song/#methods", 
            "text": "constructor  constructor (path, loop)  Path: an string, path to your sound. Loop: boolean flag. True to make it loop.   play  play ()   pause  pause ()   stop  stop ()   setVolume  setVolume (value)", 
            "title": "Methods"
        }, 
        {
            "location": "/reference/utils/", 
            "text": "Utils\n\n\nSingleton\n\n\nHelper functions that simplify working with js.\n\n\n\n\nMembers\n\n\n\n\nE_LINEAR_IN, E_LINEAR_OUT, E_LINEAR_INOUT, \nE_SINE_IN, E_SINE_OUT, E_SINE_INOUT, \nE_QUAD_IN, E_QUAD_OUT, E_QUAD_INOUT,\nE_EXPO_IN, E_EXPO_OUT, E_EXPO_INOUT, \nE_ELASTIC_IN, E_ELASTIC_OUT, E_ELASTIC_INOUT, \nE_CUBIC_IN, E_CUBIC_OUT, E_CUBIC_INOUT,\nE_CIRCULAR_IN, E_CIRCULAR_OUT, E_CIRCULAR_INOUT,\nE_BOUNCE_IN, E_BOUNCE_OUT, E_BOUNCE_INOUT, \nE_BACK_IN,  E_BACK_OUT, E_BACK_INOUT\n\n\n\nread-only\n\nEasing functions: linear (default), sine, quad, expo, elastic, cubic, circular, bounce, back.\n\n\nExample:\n \nUtils.E_ELASTIC_OUT\n\n\nOne of the most important things of the Utils, are the tweens. Here is an example on how to use it:\n\n\nExample:\n \nUtils.tween(this.sprite, \"x\", 240.0, 0.5, Utils.E_BACK_IN, this.onSpriteMoved.bind(this));\n\n\n\n\nMethods\n\n\n\n\nemptyFunc\n\n\nemptyFunc ()\n\n\n\nUseful for initialization of empty callbacks.\n\n\n\n\nisEmpty\n\n\nisEmpty (v) : Boolean\n\n\n\nCheck undefined and null\n\n\n\n\ncopyAttributes\n\n\ncopyAttributes (clone, original) : Object\n\n\n\nCopy the attributes of original into clone.\n\n\n\n\ncheckExtension\n\n\ncheckExtension (text, extension) : Boolean\n\n\n\nExample:\n \nUtils.checkExtension(\"lol.jpg\", \".png\")\n \n \nfalse\n\n\n\n\nindexToDecimal\n\n\nindexToDecimal (value) : Number\n\n\n\nConvert number in range 0..1 into 0..255. Useful for converting numbers from floating point values to old school indices.\n\n\n\n\nrgbaToString\n\n\nrgbaToString (r,g,b,a) : String\n\n\n\nEach value between 0..1\n\n\n\n\ninvoke\n\n\ninvoke (func, time)\n\n\n\nExecute function func after time seconds.\n\nNote:\n this function might change in the future.\n\n\n\n\ninvokeRepeating\n\n\ninvokeRepeating (func, time)\n\n\n\nExecute function func each time seconds.\n\nNote:\n this function might change in the future.\n\n\n\n\ndistance\n\n\ndistance (x1, y1, x2, y2) : Number\n\n\n\nReturn the distance between the two points.\n\n\n\n\nangle\n\n\nangle (x1, y1, x2, y2) : Number\n\n\n\nReturn the angle between two points.\n\n\n\n\nrandRange\n\n\nrandRange (min, max) : Number\n\n\n\nRandom between min and max (both included).\n\n\n\n\nintRandRange\n\n\nintRandRange (min, max)  : Number\n\n\n\nSame as above, but returned as int.\n\n\n\n\nrandSpread\n\n\nrandSpread (range)  : Number\n\n\n\n\n\nrandSign\n\n\nrandSign () : Number\n\n\n\n-1 or 1.\n\n\n\n\nrandFlipCoin\n\n\nrandFlipCoin () : Boolean\n\n\n\nFace or ass. Which one is which?\n\n\n\n\nscalePercentWidth\n\n\nscalePercentWidth (value) : Number\n\n\n\nA value between 0...1 will be returned as a value between 0...screen width/height.\n\n\n\n\nscalePercentHeight\n\n\nscalePercentHeight (value) : Number\n\n\n\n\n\nclamp\n\n\nclamp (min, value, max) : Number\n\n\n\n\n\nlerp\n\n\nlerp (initial, end, time) : Number\n\n\n\n\n\nperp\n\n\nperp (initial, end, time) : Number\n\n\n\n\n\nberp\n\n\nberp (initial, end, time) : Number\n\n\n\n\n\nsmoothStep\n\n\nsmoothStep (x) : Number\n\n\n\n\n\ntween\n\n\ntween( object, property, destination, time, easing, callback)\n\n\n\nObject: the instance. Property: string, the name. Destination: value. Time: total. Easing: function, see \nUtils\n.", 
            "title": "Utils"
        }, 
        {
            "location": "/reference/utils/#utils", 
            "text": "Singleton  Helper functions that simplify working with js.", 
            "title": " Utils"
        }, 
        {
            "location": "/reference/utils/#members", 
            "text": "E_LINEAR_IN, E_LINEAR_OUT, E_LINEAR_INOUT, \nE_SINE_IN, E_SINE_OUT, E_SINE_INOUT, \nE_QUAD_IN, E_QUAD_OUT, E_QUAD_INOUT,\nE_EXPO_IN, E_EXPO_OUT, E_EXPO_INOUT, \nE_ELASTIC_IN, E_ELASTIC_OUT, E_ELASTIC_INOUT, \nE_CUBIC_IN, E_CUBIC_OUT, E_CUBIC_INOUT,\nE_CIRCULAR_IN, E_CIRCULAR_OUT, E_CIRCULAR_INOUT,\nE_BOUNCE_IN, E_BOUNCE_OUT, E_BOUNCE_INOUT, \nE_BACK_IN,  E_BACK_OUT, E_BACK_INOUT  read-only \nEasing functions: linear (default), sine, quad, expo, elastic, cubic, circular, bounce, back.  Example:   Utils.E_ELASTIC_OUT  One of the most important things of the Utils, are the tweens. Here is an example on how to use it:  Example:   Utils.tween(this.sprite, \"x\", 240.0, 0.5, Utils.E_BACK_IN, this.onSpriteMoved.bind(this));", 
            "title": "Members"
        }, 
        {
            "location": "/reference/utils/#methods", 
            "text": "emptyFunc  emptyFunc ()  Useful for initialization of empty callbacks.   isEmpty  isEmpty (v) : Boolean  Check undefined and null   copyAttributes  copyAttributes (clone, original) : Object  Copy the attributes of original into clone.   checkExtension  checkExtension (text, extension) : Boolean  Example:   Utils.checkExtension(\"lol.jpg\", \".png\")     false   indexToDecimal  indexToDecimal (value) : Number  Convert number in range 0..1 into 0..255. Useful for converting numbers from floating point values to old school indices.   rgbaToString  rgbaToString (r,g,b,a) : String  Each value between 0..1   invoke  invoke (func, time)  Execute function func after time seconds. Note:  this function might change in the future.   invokeRepeating  invokeRepeating (func, time)  Execute function func each time seconds. Note:  this function might change in the future.   distance  distance (x1, y1, x2, y2) : Number  Return the distance between the two points.   angle  angle (x1, y1, x2, y2) : Number  Return the angle between two points.   randRange  randRange (min, max) : Number  Random between min and max (both included).   intRandRange  intRandRange (min, max)  : Number  Same as above, but returned as int.   randSpread  randSpread (range)  : Number   randSign  randSign () : Number  -1 or 1.   randFlipCoin  randFlipCoin () : Boolean  Face or ass. Which one is which?   scalePercentWidth  scalePercentWidth (value) : Number  A value between 0...1 will be returned as a value between 0...screen width/height.   scalePercentHeight  scalePercentHeight (value) : Number   clamp  clamp (min, value, max) : Number   lerp  lerp (initial, end, time) : Number   perp  perp (initial, end, time) : Number   berp  berp (initial, end, time) : Number   smoothStep  smoothStep (x) : Number   tween  tween( object, property, destination, time, easing, callback)  Object: the instance. Property: string, the name. Destination: value. Time: total. Easing: function, see  Utils .", 
            "title": "Methods"
        }
    ]
}